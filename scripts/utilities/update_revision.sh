#!/bin/bash
#
# Copyright 2017 IBM Corporation
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# This script opens a config/source file, reads all available repositories
# and change the ATSRC_PACKAGE_REV to the latest revision.
# Afterwards it checks if the sources file on the remote topic branch is
# different from the sources file in the local topic branch. In case it's
# not, there's nothing to be done. Otherwise, the script commits and
# pushes to the remote topic branch on the advance-toolchain fork of the
# provided user.
#
# Remarks:
# - This script uses SSH to push to GitHub, therefore you need
# the appropriate keys of the provided GitHub user.
# - Since this script automatically switches branches, it's
# recommended unstaging or stashing changes before running it.
#
# Usage:
#    update_revision <config/package/source> <github_user>

# This script requires 2 parameters.
if [[ ${#} -ne  2 ]]; then
	echo "update_revision.sh expects 2 parameters.";
	return 1;
fi

# TODO: adjust following variables.
# Assume user access GitHub password-lessly
GITHUB_USER=${2}

source ${1};

# If ATSRC_PACKAGE_CO is not defined, we skip the revision check.
if ! [ -n "${ATSRC_PACKAGE_CO}" ] || ! [ -n "${ATSRC_PACKAGE_REV}" ]; then
	return 0;
fi

# This function print a message with identation
#
# Parameters:
#     $1 - identation level. Any interger number greater or equal to zero.
#     $2 - the message.
print_msg ()
{
	for ((i=0;i<${1};i++)); do
		echo -n '-'
	done
	echo ${2}
}

# This function returns the latest revision from a git/svn repository
#
# Parameters:
#    $1 - sources config path
get_latest_revision ()
{
	if [[ ${#} -ne  1 ]]; then
		echo "Function get_latest_revision expects 1 parameter.";
		return 1;
	fi

	local isGit=$(echo ${1} | grep -c git:);
	local hash="";

	if [[ "${isGit}" == 1 ]]; then
		hash=$(git ls-remote ${1} HEAD | cut -f1)
		hash=$(git rev-parse --short=12 ${hash});
	else
		hash=$(svn info ${1} | grep Revision: | cut -d\  -f2);
	fi

	echo ${hash};
}

# This function prepares a commit and pushes it.
#
# Parameters:
#    $1 - sources config path
#    $2 - revision ID
send_to_review ()
{
	print_msg 1 "Preparing commit to send for review."

	# Check connection to GitHub
	#
	print_msg 2 "Checking connection to GitHub."
	ssh git@github.com > /dev/null 2>&1
	if [[ $? -ne 1 ]]; then
		print_msg 0 "Cannot connect to GitHub."
		return 1
	fi
	print_msg 0 "Connection can be established."

	# Get AT config and package being updated.
	# Expected a string like "<path-to-AT>/next/valgrind/source"
	pkg=$(echo ${1} | awk -F "/" '{ print $(NF-1) }')
	cfg=$(echo ${1} | awk -F "/" '{ print $(NF-3) }')

	local target_remote=git@github.com:${GITHUB_USER}/advance-toolchain.git
	local target_branch=auto-update_${cfg}_${pkg}

	# Save current branch and switch to a work branch
	#
	current_branch=$(git rev-parse --abbrev-ref HEAD)
	# -B option resets the branch if it already exists.
	git checkout -B ${target_branch}

	# Here we check if the new sources file we generated by updating the
	# revision is different from the sources file at the last commit
	# on the appropriate branch.
	# To do that, we run a git diff between our working tree and the
	# appropriate branch. Since the branch we want to compare to is
	# remote, we need to add a new temporary remote to the repo.
	git remote add TMP_DIFF ${target_remote}
	git fetch TMP_DIFF

	print_msg 2 "Checking ${pkg} revision on the topic branch"

	if [[ $(git ls-remote -h ${target_remote} | grep -c ${target_branch}) = 1 ]] \
		 && git diff --exit-code TMP_DIFF/${target_branch} -- ${1};
	then
		print_msg 0 "$pkg revision is already up to date, new commit not necessary"

		git remote remove TMP_DIFF

		git checkout ${current_branch} ${1}
		git checkout ${current_branch}
		return 0
	else
		print_msg 0 "$pkg revision is outdated, continuing commit..."
	fi

	git remote remove TMP_DIFF

	print_msg 2 "Generating a patch";
	file=$(basename $(dirname ${1}))/$(basename ${1})

	git add ${1}
	local msg="Update ${pkg} on AT ${cfg}\n\
Bump to revision ${2}\n\n"
	echo -e ${msg} | git commit -F -

	# Finally send to GitHub
	# Use topic branch to keep track of changes
	print_msg 2 "Sending commit to GitHub"
	git push --force ${target_remote} HEAD:${target_branch}

	# Switch back to original branch
	git checkout ${current_branch}
}

# This function updates a revision.
#
# Parameters:
#    $1 - sources config path
#    $2 - revision ID
update_revision ()
{
	if [[ ${#} -ne  2 ]]; then
		echo "Function update_revision expects 2 parameter.";
		return 1;
	fi

	# TODO: weak check - some revisions have less than 12 chars.
	if [[ ${2} -eq ${ATSRC_PACKAGE_REV} ]]; then
		print_msg 0 "Sources at latest revision already. Nothing to be done."
		return 0;
	fi

	print_msg 1 "Updating ${1} to the latest revision.";
	sed -e "s/ATSRC_PACKAGE_REV=.*/ATSRC_PACKAGE_REV=${2}/g" \
		${1} > ${1}.temp
	mv ${1}.temp ${1}

	print_msg 0 "Update complete.";
}

for co in ${ATSRC_PACKAGE_CO}; do
	# So far, we only update git/svn revision
	repo=$(echo $co | grep -oE \(git\|svn\):[^\ ]+);

	if [[ -n "${repo}" ]]; then
		hash=$(get_latest_revision ${repo});

		if [[ -n "${hash}" ]]; then
			echo ""
			print_msg 0 "The latest revision of ${repo} is ${hash}"
			update_revision ${1} ${hash}
			send_to_review ${1} ${hash}
			break;
		else
			print_msg 0 "Unable to connect to ${repo}"
		fi
	fi
done;
